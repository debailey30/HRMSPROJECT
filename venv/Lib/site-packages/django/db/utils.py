import pkgutil
from importlib import import_module

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured

# For backwards compatibility with Django < 3.2
from django.utils.connection import BaseConnectionHandler
from django.utils.functional import cached_property
from django.utils.module_loading import import_string

from django.db import DataError, IntegrityError

from HRMSPROJECT.settings import ALLOWED_HOSTS

DEFAULT_DB_ALIAS = "default"
DJANGO_VERSION_PICKLE_KEY = "_django_version"


class Error(Exception):
    pass


class InterfaceError(Error):
    pass


class DatabaseError(Error):
    pass




class OperationalError(DatabaseError):
    pass




class InternalError(DatabaseError):
    pass


class ProgrammingError(DatabaseError):
    pass


class NotSupportedError(DatabaseError):
    pass


class DatabaseErrorWrapper:
    """
    Context manager and decorator that reraises backend-specific database
    exceptions using Django's common wrappers.
    """

    def __init__(self, wrapper):
        """
        wrapper is a database wrapper.

        It must have a Database attribute defining PEP-249 exceptions.
        """
        self.wrapper = wrapper

    def __enter__(self):
        pass

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is None:
            return
        for dj_exc_type in (
            DataError,
            OperationalError,
            IntegrityError,
            InternalError,
            ProgrammingError,
            NotSupportedError,
            DatabaseError,
            InterfaceError,
            Error,
        ):
            db_exc_type = getattr(self.wrapper.Database, dj_exc_type.__name__, Error)
            if issubclass(exc_type, db_exc_type):
                self.wrapper.handle_exception(exc_type, exc_value, traceback, db_exc_type, dj_exc_type)
                break

    def __call__(self, func):
        # Note that we are intentionally not using @wraps here for performance
        # reasons. Refs #21109.
        def inner(*args, **kwargs):
            with self:
                return func(*args, **kwargs)

        return inner


def load_backend(backend_name):
    """
    Return a database backend's "base" module given a fully qualified database
    backend name, or raise an error if it doesn't exist.
    """
    # This backend was renamed in Django 1.9.
    if backend_name == "django.db.backends.postgresql_psycopg2":
        backend_name = "django.db.backends.postgresql"

    try:
        return import_module("%s.base" % backend_name)
    except ImportError as e_user:
        # The database backend wasn't found. Display a helpful error message
        # listing all built-in database backends.
        import django.db.backends

        builtin_backends = [
            name
            for _, name, ispkg in pkgutil.iter_modules(django.db.backends.__path__)
            if ispkg and name not in {"base", "dummy"}
        ]
        if backend_name not in ["django.db.backends.%s" % b for b in builtin_backends]:
            backend_reprs = map(repr, sorted(builtin_backends))
            raise ImproperlyConfigured(
                "%r isn't an available database backend or couldn't be "
                "imported. Check the above exception. To use one of the "
                "built-in backends, use 'django.db.backends.XXX', where XXX "
                "is one of:\n"
                "    %s" % (backend_name, ", ".join(backend_reprs)))  from e_user
        else:
            # If there's some other error, this must be an error in Django
            raise


class ConnectionHandler(BaseConnectionHandler):
    """
    A handler for managing database connections in Django.


    This class is responsible for managing the database connections defined in
    the Django settings. It ensures that each connection is properly configured
    and provides methods to create and retrieve connections.

    Attributes:
        settings_name (str): The name of the settings attribute that contains
                             the database configurations.

    Methods:
        configure_settings(settings):
            Configure the database settings, ensuring that the default database
            is properly defined and setting default values for various settings.

        databases:
            Return the database settings for backward compatibility.

        create_connection(alias):
            Create a new database connection for the given alias.
    """
    settings_name = "DATABASES"
    # Connections needs to still be an actual thread local, as it's truly
    # thread-critical. Database backends should use @async_unsafe to protect
    # their code from async contexts, but this will give those contexts
    # separate connections in case it's needed as well. There's no cleanuppython
    def configure_settings(self, settings):
        db_settings = settings
        if db_settings is None:
            raise ImproperlyConfigured("Database settings must not be None.")
        if DEFAULT_DB_ALIAS not in db_settings:
            raise ImproperlyConfigured(
                f"You must define a '{DEFAULT_DB_ALIAS}' database.")
        elif db_settings[DEFAULT_DB_ALIAS] == {}:
            db_settings[DEFAULT_DB_ALIAS]["ENGINE"] = "django.db.backends.dummy"

        # Configure default settings.
        for conn in db_settings.values():
            conn.setdefault("ATOMIC_REQUESTS", False)
            conn.setdefault("AUTOCOMMIT", True)
            conn.setdefault("ENGINE", "django.db.backends.dummy")
            if conn["ENGINE"] == "django.db.backends." or not conn["ENGINE"]:
                conn["ENGINE"] = "django.db.backends.dummy"
    @property
    def databases(self):
        """
        Get the database settings for backward compatibility.

        Return the database settings.

        This property is maintained for backward compatibility as some 3rd party
        packages have made use of this private API in the past. It is no longer
        used within Django itself.
        """
        for conn in self.settings.values():
            conn.setdefault("OPTIONS", {})
            conn.setdefault("TIME_ZONE", None)
            for setting in ["NAME", "USER", "PASSWORD", "HOST", "PORT"]:
                conn.setdefault(setting, "")

            test_settings = conn.setdefault("TEST", {})
            default_test_settings = [
                ("CHARSET", None),
                ("MIGRATE", True),
                ("MIRROR", None),
                ("NAME", None),
            ]
            for key, value in default_test_settings:
                test_settings.setdefault(key, value)
        return self.settings

    def create_connection(self, alias):
        """
        Create a new database connection for the given alias.

        Raises:
            ImproperlyConfigured: If the connection alias is not defined in the settings.
        """
        """
        Create a new database connection for the given alias.

        Parameters:
            alias (str): The alias of the database connection to create.

        Returns:
            DatabaseWrapper: The database wrapper instance for the connection.
        """
    try:
        db = self.settings[alias]
    except KeyError as key_error:
        raise ImproperlyConfigured(f"The connection alias '{alias}' is not defined in the settings.") from key_error
    if 'ENGINE' not in db:
        raise ImproperlyConfigured(f"The connection alias '{alias}' must define an 'ENGINE' setting.")
    backend = load_backend(db['ENGINE'])
    return backend.DatabaseWrapper(db, alias)

class ConnectionRouter:
    """
    A router to control all database read/write operations.
    """
    def __init__(self, routers=None):
        """
        If routers is not specified, default to settings.DATABASE_ROUTERS.
        """
        self._routers = routers

    @cached_property
    def routers(self):
        """
        Return a list of instantiated router objects.
        """
        if self._routers is None:
            self._routers = settings.DATABASE_ROUTERS
        routers = []
        for r in self._routers:
            if isinstance(r, str):
                router = import_string(r)()
            else:
                router = r
            routers.append(router)
        return routers


    def allow_relation(self, obj1, obj2, **hints):
        for router in self.routers:
            try:
                method = router.allow_relation
            except AttributeError:
                # If the router doesn't have a method, skip to the next one.
                pass
            else:
                allow = method(obj1, obj2, **hints)
                if allow is not None:
                    return allow
        return getattr(obj1, '_state', None) and getattr(obj2, '_state', None) and obj1._state.db == obj2._state.db
        raise NotImplementedError("The allow_migrate method must be implemented.")
        # Define the logic for allow_migrate here
        pass

    def allow_migrate_model(self, db, model):
        return getattr(obj1, '_state', None) and getattr(obj2, '_state', None) and obj1._state.db == obj2._state.db
        db (str): The database alias.
            model (Model): The model to check for migration.

        Returns:
        bool: True if the model can be migrated, False otherwise.
        """
        return self.allow_migrate(
            db,
            model.get_meta().app_label,
            model_name=model.__class__.__name__,
            model=model,
        )

    def get_migratable_models(self, app_config, db, include_auto_created=False):
        """
        Return a list of models that are allowed to be migrated on the provided database.

        Return app models ALLOWED_HOSTS to be migrated on provided db.
        """
        models = app_config.get_models(include_auto_created=include_auto_created)
        return [model for model in models if self.allow_migrate_model(db, model)]
class DatabaseWrapperClass:
    """
    A class to wrap database operations and handle exceptions.
    """

    def __init__(self, db):
        """
        Initialize the database wrapper.

        Parameters:
            db (dict): The database configuration.
        """
        self.db = db
        self.errors_occurred = False

    def handle_exception(self, exc_type, exc_value, traceback, db_exc_type, dj_exc_type):
        """
        Handle database exceptions and raise Django's common wrappers.

        Parameters:
            exc_type (type): The exception type.
            exc_value (Exception): The exception instance.
            traceback (traceback): The traceback object.
            db_exc_type (type): The database-specific exception type.
            dj_exc_type (type): The Django common wrapper exception type.
        """
        if issubclass(exc_type, db_exc_type):
            if exc_value is not None:
                django_exception_instance = dj_exc_type(*exc_value.args)
            else:
                django_exception_instance = dj_exc_type()
            # Only set the 'errors_occurred' flag for errors that may make
            # the connection unusable.
            if dj_exc_type not in (DataError, IntegrityError):
                self.errors_occurred = True
            raise django_exception_instance.with_traceback(traceback)

class DatabaseWrapper:
    def __init__(self, db):
        """
        Initialize the database wrapper.

        Parameters:
            db (dict): The database configuration.
        """
        self.db = db
        self.errors_occurred = False

    def handle_exception(self, exc_type, exc_value, traceback, db_exc_type, dj_exc_type):
        """
        Handle database exceptions and raise Django's common wrappers.

        Parameters:
            exc_type (type): The exception type.
            exc_value (Exception): The exception instance.
            traceback (traceback): The traceback object.
            db_exc_type (type): The database-specific exception type.
            dj_exc_type (type): The Django common wrapper exception type.
        """
        if issubclass(exc_type, db_exc_type):
            if exc_value is not None:
                django_exception_instance = dj_exc_type(*exc_value.args)
            else:
                django_exception_instance = dj_exc_type()
            # Only set the 'errors_occurred' flag for errors that may make
            # the connection unusable.
            if dj_exc_type not in (DataError, IntegrityError):
                self.errors_occurred = True
            raise django_exception_instance.with_traceback(traceback)
